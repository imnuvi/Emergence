<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Multi-Agent Simulation</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #020617;
      color: #e5e7eb;
      height: 100vh;
      overflow: hidden;
      display: flex;
    }

    .container {
      display: relative;
      width: 100%;
      height: 100%;
    }


    .sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 280px;
      height: 100%;
      max-width: 50%;
      background: #020617;
      border-right: 1px solid #111827;
      display: flex;
      z-index: 10;
      flex-direction: column;
      pointer-events: auto;
      transition: transform 0.25s ease;
      z-index: 10;
    }


    .sidebar.collapsed {
      transform: translateX(-100%);
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #111827;
      background: #020617;
    }

    .sidebar-header h1 {
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9ca3af;
    }

    .toggle-btn {
      border: none;
      background: #111827;
      color: #e5e7eb;
      border-radius: 9999px;
      padding: 0.25rem 0.75rem;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .toggle-btn:hover {
      background: #1f2937;
    }

    .sidebar-content {
      padding: 2.75rem 1rem 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .panel-section {
      margin-bottom: 0.75rem;
      padding: 0.8rem;
      border-radius: 0.75rem;
      background: #020617;
      border: 1px solid #111827;
    }

    .panel-section h2 {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }

    label {
      display: block;
      font-size: 0.75rem;
      margin-bottom: 0.25rem;
      color: #9ca3af;
    }

    input[type="number"],
    select {
      width: 100%;
      padding: 0.3rem 0.4rem;
      border-radius: 0.4rem;
      border: 1px solid #111827;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.8rem;
      margin-bottom: 0.45rem;
    }

    input[type="range"] {
      width: 100%;
      margin-top: 0.15rem;
      margin-bottom: 0.25rem;
    }

    .status-text {
      font-size: 0.7rem;
      color: #6b7280;
      margin-top: -0.1rem;
      margin-bottom: 0.25rem;
    }

    .inline-inputs {
      display: flex;
      gap: 0.5rem;
    }

    .inline-inputs > div {
      flex: 1;
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn {
      flex: 1;
      padding: 0.4rem 0.5rem;
      font-size: 0.75rem;
      border-radius: 9999px;
      border: 1px solid #111827;
      background: #020617;
      color: #e5e7eb;
      cursor: pointer;
      text-align: center;
    }

    .btn.primary {
      background: #4f46e5;
      border-color: #4f46e5;
    }

    .btn.primary:hover {
      background: #6366f1;
    }

    .btn:hover {
      background: #111827;
    }

    .sidebar-handle {
      position: absolute;
      top: 1rem;
      left: 1rem;
      z-index: 20;
    }

    .handle-btn {
      border-radius: 9999px;
      border: 1px solid #111827;
      background: #020617cc;
      color: #e5e7eb;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      cursor: pointer;
      backdrop-filter: blur(6px);
      transition: background 0.15s ease;
    }

    .handle-btn:hover {
      background: #111827;
    }


    .viewport-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      flex: 1;
      background: radial-gradient(circle at top left, #020617, #020617 55%, #000000 100%);
    }


    #viewport {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay-info {
      position: absolute;
      bottom: 0.75rem;
      left: 0.75rem;
      padding: 0.4rem 0.7rem;
      border-radius: 9999px;
      font-size: 0.7rem;
      background: #020617cc;
      color: #9ca3af;
      border: 1px solid #111827;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .sidebar {
        position: absolute;
        height: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <aside id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <h1>Controls</h1>
        <button id="collapseBtn" class="toggle-btn">Hide</button>
      </div>

      <div class="sidebar-content">
        <form id="paramsForm">
          <div class="panel-section">
            <h2>Mode</h2>
            <label>Simulation space</label>
            <input type="text" value="3D workspace" disabled />
          </div>

          <div class="panel-section">
            <h2>Agents</h2>

            <label for="numAgents">Number of agents</label>
            <input type="number" id="numAgents" name="numAgents" min="1" max="2000" value="50" />

            <label for="agentSpeed">Speed</label>
            <input type="range" id="agentSpeed" name="agentSpeed" min="0" max="10" step="0.1" value="2" />
            <div class="status-text">
              Current: <span id="agentSpeedValue">2.0</span>
            </div>

            <label for="agentSize">Agent size</label>
            <input type="range" id="agentSize" name="agentSize" min="0.05" max="0.5" step="0.01" value="0.1" />
            <div class="status-text">
              Current: <span id="agentSizeValue">0.10</span>
            </div>
          </div>

          <div class="panel-section">
            <h2>Environment</h2>

            <div class="inline-inputs">
              <div>
                <label for="envWidth">Width</label>
                <input type="number" id="envWidth" name="envWidth" value="20" step="1" />
              </div>
              <div>
                <label for="envHeight">Height</label>
                <input type="number" id="envHeight" name="envHeight" value="20" step="1" />
              </div>
            </div>

            <label>
              <input type="checkbox" id="wrapAround" name="wrapAround" checked/>
              Wrap-around boundaries
            </label>
          </div>

          <div class="panel-section">
            <h2>Controls</h2>
            <div class="btn-row">
              <button type="button" id="applyBtn" class="btn primary">Apply</button>
              <button type="button" id="resetBtn" class="btn">Reset</button>
            </div>
            <div class="btn-row">
              <button type="button" id="playPauseBtn" class="btn">⏸ Pause</button>
              <button type="button" id="stepBtn" class="btn">Step</button>
            </div>
          </div>
        </form>
      </div>
    </aside>

    <div class="sidebar-handle">
      <button id="handleBtn" class="handle-btn">☰ Controls</button>
    </div>

    <main class="viewport-wrapper">
      <canvas id="viewport"></canvas>
      <div class="overlay-info">
        Agents: <span id="infoAgents">0</span> · Mode: <span id="infoMode">3D</span>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.8.1/math.js"></script>

  <script type="importmap">
          {
          "imports": {
              "three": "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.module.js",
              "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/"
          }
      }
    </script>

  <script type="module">

  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    class SimulationParams {
      constructor() {
        this.numAgents = 6;
        this.agentSpeed = 10.0;
        this.agentSize = 0.1;
        this.envWidth = 20;
        this.envHeight = 20;
        this.envDepth = (this.envWidth + this.envHeight) / 2;
        this.wrapAround = false;

        this.interactionRadius = 2.0;
        this.springK = 0.2;         
        this.restLength = 8.0;      

        // optimization params
        this.epsilon = 0.01;
        this.rho1 = 1;
        this.rho2 = 1.5;


        // hyperparams
        this.maxiter = 1000;
        // annealing to reduce jitter
        this.sigma = 0.99995;
        
        // if gamma is same for 100, then we consider convergence
        this.maxconverge = 1000;
        this.gammaTolerance = 1e-8;
        this.temperature = 1.0;

        this.learningrate = 0.999;
        this.stepsize = 1.2;


        this.form = document.getElementById("paramsForm");
        this._bindUI();
      }

      _bindUI() {
        const speedInput = document.getElementById("agentSpeed");
        const sizeInput = document.getElementById("agentSize");
        const speedValue = document.getElementById("agentSpeedValue");
        const sizeValue = document.getElementById("agentSizeValue");

        speedInput.addEventListener("input", () => {
          speedValue.textContent = parseFloat(speedInput.value).toFixed(1);
        });

        sizeInput.addEventListener("input", () => {
          sizeValue.textContent = parseFloat(sizeInput.value).toFixed(2);
        });

        // Initial labels
        speedValue.textContent = parseFloat(speedInput.value).toFixed(1);
        sizeValue.textContent = parseFloat(sizeInput.value).toFixed(2);
      }

      readFromForm() {
        const f = this.form;
        this.numAgents = parseInt(f.numAgents.value, 10) || 1;
        this.agentSpeed = parseFloat(f.agentSpeed.value) || 0;
        this.agentSize = parseFloat(f.agentSize.value) || 0.1;
        this.envWidth = parseFloat(f.envWidth.value) || 20;
        this.envHeight = parseFloat(f.envHeight.value) || 20;
        this.envDepth = (this.envWidth + this.envHeight) / 2;
        this.wrapAround = f.wrapAround.checked;
      }

      applyToUI() {
        const f = this.form;
        f.numAgents.value = this.numAgents;
        f.agentSpeed.value = this.agentSpeed;
        f.agentSize.value = this.agentSize;
        f.envWidth.value = this.envWidth;
        f.envHeight.value = this.envHeight;
        f.wrapAround.checked = this.wrapAround;

        document.getElementById("agentSpeedValue").textContent =
          this.agentSpeed.toFixed(1);
        document.getElementById("agentSizeValue").textContent =
          this.agentSize.toFixed(2);
        document.getElementById("numAgents").value =
          this.numAgents.toString();
      }
    }

    class Agent {
      constructor(id, env, params) {
        this.id = id;
        this.env = env;
        this.params = params;
        this.force = new THREE.Vector3();

        this.position = new THREE.Vector3(
          (Math.random() - 0.5) * (params.envWidth/2),
          (Math.random() - 0.5) * (params.envHeight/2),
          0
          // o for 2d
          // (Math.random() - 0.5) * params.envDepth
        );

        // this.position = new THREE.Vector3(
        //    this.id*2,
        //   (Math.random()* 5),
        //   0
        //   // o for 2d
        //   // (Math.random() - 0.5) * params.envDepth
        // );

        this.newposition = this.position.clone();

        const angle = Math.random() * Math.PI * 2;
        this.velocity = new THREE.Vector3(
          Math.cos(angle),
          Math.sin(angle),
          0
        )
          .normalize()
          .multiplyScalar(params.agentSpeed);

        
        // const geo = new THREE.CircleGeometry(params.agentSize, 32);

        const height = params.agentSize * 0.3;
        const radius = params.agentSize;



        const geo = new THREE.CylinderGeometry(radius, radius, height, 32);



        const mat = new THREE.MeshBasicMaterial({
          // color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
          color: new THREE.Color().setHSL(0.7, 0.7, 0.6),
          side: THREE.DoubleSide
        });

        this.mesh = new THREE.Mesh(geo, mat);

        this.mesh.rotation.x = Math.PI / 2;
        this.mesh.position.copy(this.position);
        env.scene.add(this.mesh);
        env.world.add(this.mesh);

      }

      getPositionMatrix(){
        return (this.position.x,this.position.y,this.position.z);
        // return math.matrix([[this.position.x],[this.position.y],[this.position.z]]);
      }

      update(dt) {
        const p = this.params;

        this.velocity.addScaledVector(this.force, dt);
        this.position.addScaledVector(this.velocity, dt);

        const hw = p.envWidth / 2;
        const hh = p.envHeight / 2;
        const hd = p.envDepth / 2;



        if (p.wrapAround) {
          // wrap-around mode
          if (this.position.x < -hw) this.position.x += p.envWidth;
          if (this.position.x > hw) this.position.x -= p.envWidth;
          if (this.position.y < -hh) this.position.y += p.envHeight;
          if (this.position.y > hh) this.position.y -= p.envHeight;
          if (this.position.z < -hd) this.position.z += p.envDepth;
          if (this.position.z > hd) this.position.z -= p.envDepth;
        } else {
          // A: bounce boundaries (your choice)
          if (this.position.x > hw || this.position.x < -hw) {
            this.velocity.x *= -1;
          }
          if (this.position.y > hh || this.position.y < -hh) {
            this.velocity.y *= -1;
          }
          if (this.position.z > hd || this.position.z < -hd) {
            this.velocity.z *= -1;
          }
        }


        this.force.set(0, 0, 0);


        // Lets get creative and constrain agents to xy plane
        this.position.z = 0;
        this.mesh.position.z = 0;

        this.velocity.z = 0;

        this.mesh.position.copy(this.position);
      }

      newdirection(dt) {

        const nparams = this.params;

        const angle = Math.random() * Math.PI * 2;

        this.velocity = new THREE.Vector3(
          Math.cos(angle),
          Math.sin(angle),
          0
        )
          .normalize()
          .multiplyScalar(nparams.stepsize);

        if (nparams.wrapAround) {
          // wrap-around mode
          if (this.newposition.x < -hw) this.newposition.x += p.envWidth;
          if (this.newposition.x > hw) this.newposition.x -= p.envWidth;
          if (this.newposition.y < -hh) this.newposition.y += p.envHeight;
          if (this.newposition.y > hh) this.newposition.y -= p.envHeight;
          if (this.newposition.z < -hd) this.newposition.z += p.envDepth;
          if (this.newposition.z > hd) this.newposition.z -= p.envDepth;
        } 
        
        this.newposition.addScaledVector(this.velocity, dt);

      }

      setNewPosition(){
        this.position = this.newposition.clone();
        this.mesh.position.copy(this.position);
      }

      dispose() {
        this.env.scene.remove(this.mesh);
        this.env.world.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    class Environment {
      constructor(canvas, params) {
        this.canvas = canvas;
        this.params = params;
        this.agents = [];
        this.isRunning = true;



        this._setupThree();
        this._createBoundary();
        this.resetAgents();
        this._createPlane();


        this.linkGeometry = new THREE.BufferGeometry();

        this.linkMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.25,
            vertexColors: true 
        });

        this.linkLines = new THREE.LineSegments(this.linkGeometry, this.linkMaterial);

        this.world.add(this.linkLines);


        this.lastTime = performance.now();
        this._animate = this._animate.bind(this);
        requestAnimationFrame(this._animate);

        // This just calculates the P matrix once. We don't need it multiple times.
        this.P = this.buildPMatrix(this.params.numAgents);


        this.gammahistory = [];
        this.improving = true;


        this.rho = this.params.rho2-0.1; // your cutoff distance

        const maxEdges = this.agents.length * this.agents.length;

        const positions = new Float32Array(maxEdges * 2 * 3);

        this.edgeGeometry = new THREE.BufferGeometry();
        this.edgeGeometry.setAttribute(
          'position',
          new THREE.BufferAttribute(positions, 3)
        );

        const material = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 1
        });

        this.edgeLines = new THREE.LineSegments(this.edgeGeometry, material);
        this.scene.add(this.edgeLines);


        window.addEventListener("resize", () => this._onResize());
      }

      _setupThree() {
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true,
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x020617);

        this.world = new THREE.Group();
        this.world.rotation.x = -Math.PI / 2;
        this.scene.add(this.world);

        const aspect = window.innerWidth / window.innerHeight;
        this.camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        this.camera.position.set(20, 20, 20);

        // this.camera.lookAt(0, 0, 0);
        // this.controls.target.set(0, 0, 0);


        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.06;
        this.controls.enablePan = false;


        this.camera.lookAt(0, 0, 0);
        this.controls.target.set(0, 0, 0);
        this.controls.update();

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        const dir = new THREE.DirectionalLight(0xffffff, 0.7);
        dir.position.set(20, 25, 15);
        this.scene.add(ambient, dir);


      }

      _createBoundary() {
        if (this.boundaryMesh) {
          this.scene.remove(this.boundaryMesh);
        }

        const geo = new THREE.BoxGeometry(
          this.params.envWidth,
          this.params.envHeight,
          this.params.envDepth
        );
        const mat = new THREE.MeshBasicMaterial({
          color: 0x111827,
          wireframe: true,
          transparent: true,
          opacity: 0.5,
        });

        this.boundaryMesh = new THREE.Mesh(geo, mat);

        this.world.add(this.boundaryMesh);


        this.boundaryMesh.position.set(0, 0, 0);
        this.controls.target.set(0, 0, 0);
        this.camera.lookAt(0, 0, 0);
        this.controls.update();


      }

      _createPlane() {
        if (this.plane) {
          this.world.remove(this.plane);
          this.plane.geometry.dispose();
          this.plane.material.dispose();
        }

        const size = Math.max(this.params.envWidth, this.params.envHeight);

        const geo = new THREE.PlaneGeometry(size, size);
        const mat = new THREE.MeshBasicMaterial({
          color: 0x1e293b,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.4
        });

        this.plane = new THREE.Mesh(geo, mat);
        // this.plane.rotation.x = -Math.PI / 2;
        this.plane.position.set(0, 0, 0);       
        this.world.add(this.plane);
      }


      resetAgents() {
        this.agents.forEach((a) => a.dispose());

        this.agents = [];

        for (let i = 0; i < this.params.numAgents; i++) {
          this.agents.push(new Agent(i, this, this.params));
        }

        this.spawnAgentsInXPattern();

        document.getElementById("infoAgents").textContent =
          this.agents.length.toString();
        document.getElementById("infoMode").textContent = "3D";
      }

      applyNewParams(params) {
        this.params = params;
        this._createBoundary();
        this.resetAgents();

        this.controls.target.set(0, 0, 0);
        this.camera.lookAt(0, 0, 0);
        this.controls.update();

      }

      buildPMatrix(n){
        const randomInt = (min, max) => {
          // return Math.floor(Math.random() * (max - min + 1)) + min;
          return Math.random();
        };

        const ones = math.matrix(Array.from({length: n}, () => [1]));

        const randmat = [];
        for (let i = 0; i < n; i++) {
          randmat[i] = [];
          for (let j = 0; j < n-1; j++) {
              randmat[i][j] = math.random(); 
          }
        }

        const randommat = math.matrix(randmat);

        // const matrixKL = math.multiply(matrixK, matrixL);
        const numerator = math.multiply(math.transpose(ones), randommat);
        const denom = math.multiply(math.transpose(ones), ones);

        const c = math.dotDivide(numerator, denom);
        const projection = math.multiply(ones,  c);

        const B = math.subtract(randommat, projection);

        const qr = math.qr(B);

        const Q = qr.Q; 
        // const R = qr.R;
        return Q;
      }

      lambda1(L){
        const eig = math.eigs(L);
        const values = eig.values.valueOf();
        values.sort((a, b) => a[0] - b[0])

        return values[0];
      }

      lambda2(L){
        const eig = math.eigs(L);
        const values = eig.values;

        const sorted = values.slice().sort((a, b) => a - b);

        return sorted[1];

      }

      randompos(pi){

          let rx = Math.random() * 2 - 1;
          let ry = Math.random() * 2 - 1;
          let rz = 0;
          // let rz = Math.random() * 2 - 1;


          // let norm = Math.sqrt(rx*rx + ry*ry + rz*rz);
          // rx /= norm;
          // ry /= norm;
          // rz /= norm;

          let step = this.params.stepsize;

          const newX = pi.x + rx * step;
          const newY = pi.y + ry * step;
          const newZ = pi.z + rz * step;
          const newpos = new THREE.Vector3(newX, newY, newZ)
          return newpos;

      }

      proposeNewPosition(positions, i){
        //

        const N = positions.length;
        let newpositions = [];

        if (i !== undefined){
          const pi = positions[i];

          newpositions  = positions.slice();
          newpositions[i] = this.randompos(pi);
        }

        else{
          for (let i = 0; i < N; i++) {

            const pi = positions[i];
            let newpos = this.randompos(pi);
            newpositions.push(newpos);
          }

        }

        return newpositions;
        
      }

      updateEdges() {
        // We save edges separately to reduce computation.
          const agents = this.agents;
          const rhoSq = this.rho * this.rho;

          const posAttr = this.edgeGeometry.getAttribute('position');
          const array = posAttr.array;

          let ai = new THREE.Vector3();
          let aj = new THREE.Vector3();


          let ptr = 0;  

          for (let i = 0; i < agents.length; i++) {
            agents[i].mesh.getWorldPosition(ai);

            for (let j = i + 1; j < agents.length; j++) {
              agents[j].mesh.getWorldPosition(aj);

              const dx = aj.x - ai.x;
              const dy = aj.y - ai.y;
              const dz = aj.z - ai.z;

              const distSq = dx*dx + dy*dy + dz*dz;

              if (distSq <= rhoSq) {
                array[ptr++] = ai.x;
                array[ptr++] = ai.y;
                array[ptr++] = ai.z;

                array[ptr++] = aj.x;
                array[ptr++] = aj.y;
                array[ptr++] = aj.z;
              }
            }
          }

          while (ptr < array.length) {
            array[ptr++] = 0;
          }

          posAttr.needsUpdate = true;
        }


      calculateWeightedLaplacian(positions){
        // Initial positions and values
        const epsilon = this.params.epsilon;
        const rho1 = this.params.rho1;
        const rho2 = this.params.rho2;

        const N = positions.length;
        const weighted_laplacian = Array.from({ length: positions.length }, () => new Array(positions.length).fill(0));

        let conditions = true;

        for (let i = 0; i < N; i++) {
            const pi = positions[i];

            let weightsum = 0;
            // weighted_laplacian[i] = [];

            for (let j = 0; j < N; j++) {
                const pj = positions[j];

                if (i == j){
                  continue;
                }
                const dx = pj.x - pi.x;
                const dy = pj.y - pi.y;
                const dz = pj.z - pi.z;

                const distSq = dx*dx + dy*dy + dz*dz;
                const dist = Math.sqrt(distSq);

                if (dist < rho1) {
                  conditions = false;    
                }

                let weight;

                // if (dist >= rho2) {
                //     weight = 0;
                // } else {
                    weight = epsilon ** ((rho1 - dist) / (rho1 - rho2));
                // }

                // bad old logic
                // const weight = epsilon * math.exp((rho1 - dist) / (rho1 - rho2));

                weightsum += weight;
                weighted_laplacian[i][j] = -weight;
                weighted_laplacian[j][i] = -weight;
            }
            weighted_laplacian[i][i] = weightsum;
        }

        // return weighted_laplacian;
        return [conditions, weighted_laplacian];

      }

      linearizedDistanceConstraint(xi_old, xj_old, xi_new, xj_new, tolerance = 1e-6) {
          // Constraint between old and new pos for distance


            const odx = xi_old.x - xj_old.x;
            const ody = xi_old.y - xj_old.y;
            const odz = xi_old.z - xj_old.z;

            const dij_old = Math.sqrt(odx*odx + ody*ody + odz*odz);



            const ndx = xi_new.x - xj_new.x;
            const ndy = xi_new.y - xj_new.y;
            const ndz = xi_new.z - xj_new.z;

            const dij_new = Math.sqrt(ndx*ndx + ndy*ndy + ndz*ndz);


            const lhs = 2 * (ndx*odx + ndy*ody + ndz*odz);

            const rhs = dij_new + dij_old;

            return Math.abs(lhs - rhs) <= tolerance;
        }
        
        linearizedConstraintAll(oldpos, newpos, tolerance = 1e-6) {

            const N = newpos.length;

            for (let i = 0; i < N; i++) {
                for (let j = i + 1; j < N; j++) {
                    if (!this.linearizedDistanceConstraint(oldpos[i], oldpos[j], newpos[i], newpos[j], tolerance)) {
                        return false;
                    }
                }
            }

            return true;
        }

      spawnAgentsInXPattern() {
        // Let's spawn them in a X pattern
        const agents = this.agents;
        const N = agents.length;

        const half = Math.floor(N / 2);
        const spacing = this.params.initialSpacing || 2.0;
        const jitter = 0.8;

        for (let i = 0; i < half; i++) {
            const t = (i - (half-1)/2) * spacing;

            let x = t;
            let y = t;
            let z = 0;
            x += (Math.random()-0.5)*jitter;
            y += (Math.random()-0.5)*jitter;


            agents[i].position.set(x, y, z);
            agents[i].mesh.position.set(x, y, z);
        }

        for (let i = half; i < N; i++) {
            const j = i - half;
            const t = (j - (N-half-1)/2) * spacing;

            let x = t;
            let y = -t;
            let z = 0;

            x += (Math.random()-0.5)*jitter;
            y += (Math.random()-0.5)*jitter;

            agents[i].position.set(x, y, z);
            agents[i].mesh.position.set(x, y, z);
        }
    }




      connectivitySolver(){

        let ndistSq;
        let odistSq;
        let pi, pj, npi, npj;
        let gamma, weighted_laplacian, PTLP_minus_gammaI, nagentconds, oagentconds, bestgamma, bestpos, conditions, improving;
        let agents = this.agents;
        let agentpositions = agents.map(agent => agent.position);

        [conditions, weighted_laplacian] = this.calculateWeightedLaplacian(agentpositions);

        bestgamma = this.lambda2(weighted_laplacian);

        bestpos = agentpositions;



        for (let i = 0; i < agentpositions.length; i++) {

          let agentpos = agentpositions[i];
          let newpositions = agentpositions.slice();
          newpositions[i] = this.proposeNewPosition(agentpositions, i)[i];

          for (let x = 0; x< this.params.maxiter; x++){

            // let newpositions = this.proposeNewPosition(agentpositions);
            // let newpositions = this.proposeNewPosition(agentpositions);

            if (this.linearizedConstraintAll(agentpositions, newpositions, 1e-6)){
              continue;
            }

            [conditions, weighted_laplacian] = this.calculateWeightedLaplacian(newpositions);

            const gamma = this.lambda2(weighted_laplacian);

            if (gamma > bestgamma && conditions == true){
              bestgamma = gamma;
              bestpos = newpositions;
            }

            this.gammahistory.push(bestgamma);

            if (this.gammahistory.length > this.params.maxconverge){
                this.gammahistory.shift();
            }
            if (this.gammahistory.length < this.params.maxconverge){
                continue;
            }

            improving = false;

            for (let i = 1; i < this.gammahistory.length; i++) {
                if (this.gammahistory[i] - this.gammahistory[i-1] > this.params.gammaTolerance) {
                    improving = true;
                    break;
                }
            }

            if (!improving) {
              break;
            }
          }
          bestpos[i] = bestpos[i];
          
        }

        // let efficiency = ngamma / (1 + Math.abs(ngamma))
        agents.forEach((agent, index) => {
          agent.position = bestpos[index];
          agent.mesh.position.copy(agent.position);
        });


        improving = true;

        // this.params.sigma *= this.params.sigma;
        return [gamma, improving];
      }


      _onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.camera.aspect = w / h;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(w, h);
      }

      _animate(now) {
        // let efficiency = 0.00001;
        // console.log(now)

        const dt = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // this.params.stepsize *= this.params.learningrate;

        // console.log(this.isRunning && this.improving);

        if (this.isRunning && this.improving) {

          let [gamma, improving] = this.connectivitySolver();
          this.improving = improving;
          // let efficiency = gamma / (Math.abs(gamma) + 1);
          //   // agent.update(dt);
          //   // agent.newdirection(dt);
          //   // agent.setNewPosition();
          //   // this.updateConnectionsAndForces(); 
          // }
          // this.connectivitySolver();
        }
          // }
          this.updateEdges();

          this.controls.update();
          this.renderer.render(this.scene, this.camera);
          requestAnimationFrame(this._animate);
        }

      step(dt = 1 / 60) {
        this.agents.forEach((a) => a.update(dt));
        this.renderer.render(this.scene, this.camera);
      }
    }

    const canvas = document.getElementById("viewport");
    const params = new SimulationParams();
    params.applyToUI();
    params.readFromForm();
    let env = new Environment(canvas, params);

    const applyBtn = document.getElementById("applyBtn");
    const resetBtn = document.getElementById("resetBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const stepBtn = document.getElementById("stepBtn");

    applyBtn.addEventListener("click", () => {
      params.readFromForm();
      env.applyNewParams(params);
    });

    resetBtn.addEventListener("click", () => {

      // reset to defaults
      const fresh = new SimulationParams();
      params.numAgents = fresh.numAgents;
      params.agentSpeed = fresh.agentSpeed;
      params.agentSize = fresh.agentSize;
      params.envWidth = fresh.envWidth;
      params.envHeight = fresh.envHeight;
      params.envDepth = fresh.envDepth;
      params.wrapAround = fresh.wrapAround;
      params.applyToUI();
      env.applyNewParams(params);
    });

    playPauseBtn.addEventListener("click", () => {
      env.isRunning = !env.isRunning;
      playPauseBtn.textContent = env.isRunning ? "⏸ Pause" : "▶ Play";
    });

    stepBtn.addEventListener("click", () => {
      env.step();
    });

    const sidebar = document.getElementById("sidebar");
    const collapseBtn = document.getElementById("collapseBtn");
    const handleBtn = document.getElementById("handleBtn");

    collapseBtn.addEventListener("click", () => {
      sidebar.classList.add("collapsed");
    });

    handleBtn.addEventListener("click", () => {
      sidebar.classList.toggle("collapsed");
    });
  </script>
</body>
</html>
